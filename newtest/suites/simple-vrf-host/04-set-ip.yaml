name: set-ip
description: >
  Step 3 of incremental VRF setup: assign IP 10.10.1.1/31 to Ethernet2 in CUSTOMER VRF.
  Includes diagnostics to understand intfmgrd IP assignment pipeline.
topology: 2node
requires: [bind-interface]

steps:
  # Assign IP to Ethernet2 (already bound to CUSTOMER VRF).
  # Writes INTERFACE|Ethernet2 (base, NULL sentinel) + INTERFACE|Ethernet2|10.10.1.1/31
  # to CONFIG_DB. intfmgrd processes → assigns IP in kernel → writes APP_DB INTF_TABLE.
  - name: set-ip-ethernet2
    action: set-interface
    devices: [switch2]
    interface: Ethernet2
    params:
      property: ip
      value: "10.10.1.1/31"

  # Verify CONFIG_DB has the IP entry.
  - name: verify-ip-config-db
    action: verify-config-db
    devices: [switch2]
    table: INTERFACE
    key: "Ethernet2|10.10.1.1/31"
    expect:
      exists: true

  # Also verify the base entry still has vrf_name=CUSTOMER (SetIP writes NULL:NULL
  # to base entry via HSET which should NOT overwrite existing vrf_name field).
  - name: verify-base-entry-vrf-intact
    action: verify-config-db
    devices: [switch2]
    table: INTERFACE
    key: Ethernet2
    expect:
      fields:
        vrf_name: CUSTOMER

  # Poll for intfmgrd to assign IP in kernel.
  - name: poll-ethernet2-ip-in-kernel
    action: ssh-command
    devices: [switch2]
    command: "for i in 1 2 3 4 5 6; do ip addr show Ethernet2 | grep -q '10.10.1.1' && break; sleep 5; done; true"

  # Diagnose: what is APP_DB INTF_TABLE state?
  # If intfmgrd processed the IP, it writes INTF_TABLE. If empty, intfmgrd hasn't processed it.
  - name: diagnose-appdb-intf-table
    action: ssh-command
    devices: [switch2]
    command: "redis-cli -n 0 keys 'INTF_TABLE:Ethernet2*'"

  # Diagnose: manually add the IP to see if kernel accepts it on a VRF-bound interface.
  - name: diagnose-manual-ip-add
    action: ssh-command
    devices: [switch2]
    command: "sudo ip addr add 10.10.1.1/31 dev Ethernet2 2>&1 || true; ip addr show Ethernet2"

  # Verify IP is in kernel (either from intfmgrd or manual add above).
  - name: verify-ethernet2-ip-in-kernel
    action: ssh-command
    devices: [switch2]
    command: "ip addr show Ethernet2"
    expect:
      contains: "10.10.1.1"

  # Wait for orchagent to read APP_DB INTF_TABLE and create SAI route entry.
  # intfmgrd writes to APP_DB; orchagent reads it and programs NGDP via SAI.
  - name: poll-appdb-intf-entry
    action: ssh-command
    devices: [switch2]
    command: "for i in 1 2 3 4 5 6 7 8 9 10 11 12; do redis-cli -n 0 keys 'INTF_TABLE:Ethernet2:*' | grep -q '10.10.1.1' && break; sleep 5; done; true"

  - name: verify-appdb-intf-entry
    action: ssh-command
    devices: [switch2]
    command: "redis-cli -n 0 keys 'INTF_TABLE:Ethernet2:*'"
    expect:
      contains: "10.10.1.1"

  # Poll for orchagent to program the connected route 10.10.1.0/31 in ASIC_DB.
  - name: poll-route-in-asicdb
    action: ssh-command
    devices: [switch2]
    command: "for i in 1 2 3 4 5 6 7 8 9 10 11 12; do redis-cli -n 1 keys 'ASIC_STATE:SAI_OBJECT_TYPE_ROUTE_ENTRY:*' | grep -q '10.10.1.0' && break; sleep 5; done; true"

  # Verify the connected route exists in ASIC_DB.
  - name: verify-route-in-asicdb
    action: ssh-command
    devices: [switch2]
    command: "redis-cli -n 1 keys 'ASIC_STATE:SAI_OBJECT_TYPE_ROUTE_ENTRY:*' | grep '10.10.1.0'"
    expect:
      contains: "10.10.1.0"
